---
title: "MLHC Final Project"
author: "Xinmi Li"
date: "April 25, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries
```{r}
library(plyr)
library(dplyr)
library(data.table)
library(mice)
library(Amelia)
```

Load tables with needed data
```{r}
adm <- data.frame(read.csv(file = "/Users/Xinmi/git/MLforHC_FinalProject/adm.csv", header = TRUE))
adm.original <- data.frame(read.csv(file = "/Users/Xinmi/git/MLforHC_FinalProject/ADMISSIONS.csv", header = TRUE))
ds <- data.frame(read.csv(file = "/Users/Xinmi/git/MLforHC_FinalProject/ds.csv", header = TRUE))
pts <- data.frame(read.csv(file = "/Users/Xinmi/git/MLforHC_FinalProject/pts.csv", header = TRUE))
surgpts <- data.frame(read.csv(file = "/Users/Xinmi/git/MLforHC_FinalProject/surgpts.csv", header = TRUE))
rx <- fread("/Users/Xinmi/git/MLforHC_FinalProject/PRESCRIPTIONS.csv", header = T, sep = ",") %>% 
  select(SUBJECT_ID, HADM_ID, DRUG, FORMULARY_DRUG_CD)%>% 
  filter(SUBJECT_ID %in% surgpts$SUBJECT_ID)
cesurg <- fread('/Users/Xinmi/git/MLforHC_FinalProject/cesurg.csv', header = T, sep = ',')
```


Data pre-processing
```{r}
# Clean the table to leave only the most recent admission for each patient
adm2 <- adm.original %>% 
  filter(SUBJECT_ID %in% adm$SUBJECT_ID) %>% 
  group_by(SUBJECT_ID) %>%
  filter(as.numeric(ADMITTIME) == max(as.numeric(ADMITTIME))) %>%
  select(SUBJECT_ID, HADM_ID, DIAGNOSIS)

# Since multiple diagnoses are assigned with one patient, and the SEQ_NUM shows the priority
# of diagnoses, here only the prior diagnosis is kept.
ds2 <- ds %>%
  select(SUBJECT_ID, HADM_ID, SEQ_NUM, ICD9_CODE, SHORT_TITLE) %>% 
  filter(HADM_ID %in% adm2$HADM_ID & SEQ_NUM == 1)

rx2 <- rx %>%
  select(SUBJECT_ID, HADM_ID, DRUG, FORMULARY_DRUG_CD) %>% 
  filter(HADM_ID %in% adm2$HADM_ID)

# Select only the top 10 commonly used drugs (based on drug code)
drug10 <- table(rx2$FORMULARY_DRUG_CD) %>%
  sort(decreasing = TRUE) %>%
  names() %>%
  head(10)
  
rx3 <- rx2 %>%
  filter(FORMULARY_DRUG_CD == drug10)

rx4 <- cbind(rx3[,1:3], model.matrix( ~ FORMULARY_DRUG_CD - 1, data=rx3)) %>%
  select(-DRUG)

SUBJECT_ID <- unique(rx4$SUBJECT_ID)
rx4.list <- do.call(rbind, by(rx4[,c(3:12)], rx4$SUBJECT_ID, FUN=colSums))
rx4.table <- as.data.frame(cbind(SUBJECT_ID, rx4.list))

# One patient can be given the same drug multiple times during one admission. Since we only
# care whether the patient is given this drug, all non-zero numbers in drug columns are mapped
# to 1.

rx5 <- cbind(SUBJECT_ID, apply(rx4.table[,2:11], 2, FUN = function(x) {as.numeric(x!=0)})) %>%
  as.data.frame()
colnames(rx5) <- c("SUBJECT_ID","D5W250", "FURO40I", "INSULIN", "LR1000", "MAG2PM", "METO5I", 
                          "NACLFLUSH", "NS1000", "NS250", "NS500")

# Select some vitals (based on references) from chart events and transform them to
# to min/mean/max value for each patient.
cesurg2 <- cesurg %>%
  select(SUBJECT_ID, HADM_ID, ITEMID, VALUE, VALUENUM, VALUEUOM, LABEL) %>% 
  filter(HADM_ID %in% adm2$HADM_ID)

cesurg2.RR <- subset(cesurg2, grepl("Respiratory Rate", cesurg2$LABEL, ignore.case = TRUE))
cesurg2.RR.aggr <- aggregate(VALUENUM ~ SUBJECT_ID, data = cesurg2.RR, FUN = mean)
colnames(cesurg2.RR.aggr)[2] <- "RR"

cesurg2.SPO2 <- subset(cesurg2, grepl("SpO2", cesurg2$LABEL, ignore.case = TRUE))
cesurg2.SPO2.aggr <- aggregate(VALUENUM ~ SUBJECT_ID, data = cesurg2.SPO2, FUN = mean)
colnames(cesurg2.SPO2.aggr)[2] <- "SPO2"

cesurg2.T <- subset(cesurg2, grepl("Temperature F", cesurg2$LABEL, ignore.case = TRUE))
cesurg2.T.aggr <- aggregate(VALUENUM ~ SUBJECT_ID, data = cesurg2.T, FUN = mean)
colnames(cesurg2.T.aggr)[2] <- "T"

cesurg2.BP <- subset(cesurg2, grepl("BP Systolic", cesurg2$LABEL, ignore.case = TRUE))
cesurg2.BP.aggr <- aggregate(VALUENUM ~ SUBJECT_ID, data = cesurg2.BP, FUN = mean)
colnames(cesurg2.BP.aggr)[2] <- "BP"

cesurg2.HR <- subset(cesurg2, grepl("Heart Rate", cesurg2$LABEL, ignore.case = TRUE))
cesurg2.HR.aggr <- aggregate(VALUENUM ~ SUBJECT_ID, data = cesurg2.HR, FUN = mean) 
colnames(cesurg2.HR.aggr)[2] <- "HR"

# Combine the tables into one 
df <- pts %>%
  inner_join(adm2 %>% select(DIAGNOSIS), by="SUBJECT_ID") %>%
  left_join(ds2 %>% select(SUBJECT_ID, ICD9_CODE, SHORT_TITLE), by="SUBJECT_ID") %>%
  left_join(rx5, by="SUBJECT_ID")  %>%
  left_join(cesurg2.RR.aggr, by="SUBJECT_ID") %>%
  left_join(cesurg2.SPO2.aggr, by="SUBJECT_ID") %>%
  left_join(cesurg2.T.aggr, by="SUBJECT_ID") %>%
  left_join(cesurg2.BP.aggr, by="SUBJECT_ID") %>%
  left_join(cesurg2.HR.aggr, by="SUBJECT_ID") 
```


Process missing values
```{r, cache=TRUE}
# Check the missing values
md.pattern(df)

# Drop patients with more than 5 missing items and colomns with over 50% missing values
df2 <- df[-which(rowSums(is.na(df)) > 5),-which(colMeans(is.na(df)) > 0.5)]
md.pattern(df2)

# Since ICD-9 Code and Short Title (description) cannot be imputed, the 47 patients with only
# these two missing items are also dropped.
df3 <- df2[-which(is.na(df2$ICD9_CODE)),]

# Categorizing the patients based on ICD-9 Code Groups (first 3 digits), drop patients with 
# V Codes (Supplemental Codes, unable to categorize).
df4 <- df3 %>% 
  subset(!grepl("V", df3$ICD9_CODE))

ICD.break <- c(001, 140, 240, 280, 290, 320, 390, 460, 520, 580, 630, 680, 710, 740, 760, 
               780, 790, 797, 800, 999)

df4$ICD9_CODE <- substr(df4$ICD9_CODE, 0, 3) %>%
  as.numeric() %>%
  cut(breaks = ICD.break, include.lowest=TRUE)

df4[sapply(df4, (function(x) length(unique(x))<3))]  <-
  lapply(df4[,sapply(df4, (function(x) length(unique(x))<3))], as.factor)

# Impute missing values
df5 <- amelia(df4, m = 5, p2s = 0, idvars = names(df4[,1:16]))$imputations[[5]]
md.pattern(df4)
md.pattern(df5)
# By comparing the missing patterns of data with/without imputation, 61 patients still have 
# missing values unable to be imputed, so they are dropped.
df6 <- na.omit(df5)

# Get train and test sets
set.seed(123456789)
ordering <- sample(1:nrow(df6))
train <- df6[ordering[1:round(0.5*nrow(df6))],]
test <- df6[-ordering[1:round(0.5*nrow(df6))], ]
```

Build models
```{r, cache=TRUE}
```